= TFHE Java
:author:        Rui LOPES
:owner:         rdlopes
:email:         mailto:rui.d.lopes@me.com
:project:       tfhe-java
:key:           {owner}_{project}
:repo:          https://github.com/{owner}/{project}
:native:        {repo}/actions/workflows/native.yaml
:ci:            {repo}/actions/workflows/ci.yaml
:cd:            {repo}/actions/workflows/cd.yaml
:linkedin:      https://www.linkedin.com/in/rdlopes-fr
:badges:        https://img.shields.io/badge
:license:       https://opensource.org/licenses/MIT

image:{badges}/License-MIT-yellow.svg[link={license},title=MIT License]
image:{native}/badge.svg[link={native},window=_blank]
image:{ci}/badge.svg[link={ci},window=_blank]
image:{cd}/badge.svg[link={cd},window=_blank]

https://docs.zama.ai/tfhe-rs[Zama TFHE^] wrapper enabling homomorphic encryption in Java using the Foreign Function & Memory API (Project Panama).

== Overview

TFHE Java is a Java wrapper for the https://github.com/zama-ai/tfhe-rs[Zama TFHE-rs library], providing access to Torus Fully Homomorphic Encryption (TFHE) operations directly from Java applications.
This library enables developers to perform computations on encrypted data without decrypting it first, ensuring privacy and security in cloud computing scenarios.

=== What is TFHE?

TFHE (Torus Fully Homomorphic Encryption) is a cryptographic scheme that allows arbitrary computations to be performed on encrypted data without revealing the underlying plaintext.
Key features include:

* **Fully Homomorphic**: Supports both addition and multiplication operations on encrypted data
* **Bootstrapping**: Automatic noise management to enable unlimited operations
* **Fast Operations**: Optimized for practical performance in real-world applications
* **Boolean and Integer Support**: Works with both boolean circuits and integer arithmetic

=== Key Benefits

* **Privacy-Preserving Computing**: Perform calculations on sensitive data without exposing it
* **Cloud Security**: Enable secure outsourced computation to untrusted servers
* **Zero-Knowledge Processing**: Process data without learning anything about its content
* **Regulatory Compliance**: Meet strict data protection requirements (GDPR, HIPAA, etc.)

== Installation

Add the following dependency to your `pom.xml`:

[source,xml]
----
<dependency>
    <groupId>io.github.rdlopes</groupId>
    <artifactId>tfhe-java</artifactId>
    <version>[VERSION]</version>
</dependency>
----

=== Requirements

* **Java 24** or later (requires Foreign Function & Memory API support)
* **JVM Arguments**: `--enable-native-access=ALL-UNNAMED`
* **Native Libraries**: Automatically included in the JAR

== Quick Start

Here's a simple example of performing homomorphic addition:

[source,java]
----
import ai.zama.tfhe.U128;

import java.lang.foreign.Arena;
import java.lang.foreign.MemorySegment;

import static ai.zama.tfhe.TfheNative.*;

public static void main(String... args) {
  // Generate configuration and keys
  try (Arena arena = Arena.ofConfined()) {
      // Create configuration
      MemorySegment configBuilder = arena.allocate(C_POINTER);
      config_builder_default(configBuilder);

      MemorySegment config = arena.allocate(C_POINTER);
      config_builder_build(configBuilder.get(C_POINTER, 0), config);

      // Generate client and server keys
      MemorySegment clientKey = arena.allocate(C_POINTER);
      MemorySegment serverKey = arena.allocate(C_POINTER);
      generate_keys(config.get(C_POINTER, 0), clientKey, serverKey);
      set_server_key(serverKey.get(C_POINTER, 0));

      // Prepare values to encrypt
      MemorySegment value1 = U128.allocate(arena);
      U128.w0(value1, 42);
      U128.w1(value1, 0);
      MemorySegment value2 = U128.allocate(arena);
      U128.w0(value2, 57);
      U128.w1(value2, 0);

      // Encrypt the values
      MemorySegment encrypted1 = U128.allocate(arena);
      fhe_uint128_try_encrypt_with_client_key_u128(value1, clientKey.get(C_POINTER, 0), encrypted1);
      MemorySegment encrypted2 = U128.allocate(arena);
      fhe_uint128_try_encrypt_with_client_key_u128(value2, clientKey.get(C_POINTER, 0), encrypted2);

      // Perform homomorphic addition
      MemorySegment result = U128.allocate(arena);
      fhe_uint128_add(encrypted1, encrypted2, result);

      // Decrypt result
      MemorySegment decrypted = U128.allocate(arena);
      fhe_uint128_decrypt(result, clientKey.get(C_POINTER, 0), decrypted);

      System.out.println("Result: " + U128.w0(decrypted)); // Prints: 99
  }
}
----

== Project Structure

=== Core Components

[source]
----
tfhe-java/
├── src/                                     # Java source code
├── target/
│   ├── classes/native/                      # Native libraries (runtime)
│   └── generated-sources/tfhe-rs/           # Generated Java bindings
├── tfhe-rs/                                 # Rust TFHE implementation (submodule)
├── pom.xml                                  # Maven configuration
└── README.adoc                              # This documentation
----

=== Generated Bindings

The build process automatically generates Java bindings from the TFHE-rs C API:

* **Package**: `ai.zama.tfhe`
* **Main Class**: `TfheNative` - Contains all native function bindings
* **Data Types**: `U128`, `Boolean` - Wrapper classes for TFHE data types
* **Memory Management**: Uses Java's Foreign Function & Memory API

=== Key Codebase Parts

==== Native Function Bindings (`TfheNative.java`)

Generated class containing all TFHE operations:

* **Key Generation**: `generate_keys()`, `boolean_generate_keys()`
* **Encryption**: `fhe_uint128_encrypt()`, `boolean_client_key_encrypt()`
* **Decryption**: `fhe_uint128_decrypt()`, `boolean_client_key_decrypt()`
* **Operations**: `fhe_uint128_add()`, `fhe_uint128_sub()`, `boolean_server_key_xor()`

==== Data Type Wrappers

* **U128**: 128-bit unsigned integer operations
* **Boolean**: Boolean circuit operations
* **Memory Segments**: Direct memory access for performance

=== TFHE-rs Submodule

The project includes the complete Zama TFHE-rs library as a Git submodule:

* **Core Library** (`tfhe/`): Main TFHE implementation
* **FFT Operations** (`tfhe-fft/`): Fast Fourier Transform optimizations
* **Number Theory** (`tfhe-ntt/`): Number Theoretic Transform
* **Zero-Knowledge** (`tfhe-zk-pok/`): Zero-knowledge proofs
* **Benchmarks** (`tfhe-benchmark/`): Performance testing

== Building from Source

For most users, the library is available through Maven Central and doesn't require building from source.
However, if you need to build locally:

=== Standard Build

[source,bash]
----
# Clone the repository
git clone https://github.com/rdlopes/tfhe-java.git
cd tfhe-java

# Build the project
./mvnw package
----

**Prerequisites:**
* **Java 24** (Temurin distribution recommended)

[source,bash]
----
# Using SDKMAN
sdk install java 24-tem
sdk use java 24-tem
----

The build process automatically downloads pre-built native libraries and Java bindings, making it simple to get started without complex toolchain setup.

== Usage Examples

=== Boolean Operations

Here's how to perform homomorphic boolean operations:

[source,java]
----
import java.lang.foreign.Arena;
import java.lang.foreign.MemorySegment;
import static ai.zama.tfhe.TfheNative.*;

public void booleanExample() {
    try (Arena arena = Arena.ofConfined()) {
        // Generate boolean keys
        MemorySegment clientKey = arena.allocate(C_POINTER);
        MemorySegment serverKey = arena.allocate(C_POINTER);
        boolean_generate_keys(clientKey, serverKey);
        boolean_set_server_key(serverKey.get(C_POINTER, 0));

        // Encrypt boolean values
        MemorySegment encryptedTrue = arena.allocate(C_POINTER);
        MemorySegment encryptedFalse = arena.allocate(C_POINTER);
        boolean_client_key_encrypt(clientKey.get(C_POINTER, 0), true, encryptedTrue);
        boolean_client_key_encrypt(clientKey.get(C_POINTER, 0), false, encryptedFalse);

        // Perform XOR operation
        MemorySegment result = arena.allocate(C_POINTER);
        boolean_server_key_xor(encryptedTrue.get(C_POINTER, 0), encryptedFalse.get(C_POINTER, 0), result);

        // Decrypt result
        boolean decrypted = boolean_client_key_decrypt(clientKey.get(C_POINTER, 0), result.get(C_POINTER, 0));
        System.out.println("XOR result: " + decrypted); // true
    }
}
----

=== Integer Arithmetic

Perform arithmetic operations on encrypted integers:

[source,java]
----
import ai.zama.tfhe.U128;
import java.lang.foreign.Arena;
import java.lang.foreign.MemorySegment;
import static ai.zama.tfhe.TfheNative.*;

public void integerArithmetic() {
    try (Arena arena = Arena.ofConfined()) {
        // Setup configuration and keys
        MemorySegment configBuilder = arena.allocate(C_POINTER);
        config_builder_default(configBuilder);
        MemorySegment config = arena.allocate(C_POINTER);
        config_builder_build(configBuilder.get(C_POINTER, 0), config);

        MemorySegment clientKey = arena.allocate(C_POINTER);
        MemorySegment serverKey = arena.allocate(C_POINTER);
        generate_keys(config.get(C_POINTER, 0), clientKey, serverKey);
        set_server_key(serverKey.get(C_POINTER, 0));

        // Encrypt values
        MemorySegment value1 = U128.allocate(arena);
        U128.w0(value1, 100);
        U128.w1(value1, 0);

        MemorySegment value2 = U128.allocate(arena);
        U128.w0(value2, 25);
        U128.w1(value2, 0);

        MemorySegment encrypted1 = U128.allocate(arena);
        MemorySegment encrypted2 = U128.allocate(arena);
        fhe_uint128_try_encrypt_with_client_key_u128(value1, clientKey.get(C_POINTER, 0), encrypted1);
        fhe_uint128_try_encrypt_with_client_key_u128(value2, clientKey.get(C_POINTER, 0), encrypted2);

        // Perform subtraction
        MemorySegment result = U128.allocate(arena);
        fhe_uint128_sub(encrypted1, encrypted2, result);

        // Decrypt and display result
        MemorySegment decrypted = U128.allocate(arena);
        fhe_uint128_decrypt(result, clientKey.get(C_POINTER, 0), decrypted);
        System.out.println("Subtraction result: " + U128.w0(decrypted)); // 75
    }
}
----

=== Memory Management Best Practices

Always use `Arena.ofConfined()` for automatic memory cleanup:

[source,java]
----
try (Arena arena = Arena.ofConfined()) {
    MemorySegment data = arena.allocate(C_POINTER);
    // Use data for TFHE operations...
} // Automatic cleanup when arena closes
----

=== Error Handling

TFHE native functions return 0 for success, non-zero for errors:

[source,java]
----
int result = fhe_uint128_add(lhs, rhs, output);
if (result != 0) {
    throw new RuntimeException("TFHE operation failed with code: " + result);
}
----

=== Performance Tips

* **Key Reuse**: Generate keys once and reuse them across operations
* **Memory Efficiency**: Use appropriate data types (U128 for integers, Boolean for binary operations)
* **Batch Operations**: Group multiple operations when possible to reduce overhead
* **Resource Management**: Always use try-with-resources for Arena management

== License

This project is licensed under the MIT License - see the link:{license}[LICENSE] for details.

== Author

image:{badges}/By_Mail-white?style=social&logo=icloud&label=Rui_LOPES[link={email},window=_blank]

image:{badges}/On_LinkedIn-white?style=social&logo=logmein&label=Rui_LOPES[link={linkedin},window=_blank]

== Acknowledgments

* https://www.zama.ai/[Zama] for the excellent TFHE-rs library
* OpenJDK Project Panama for Foreign Function & Memory API
* The homomorphic encryption research community
