= TFHE Java
:author:        Rui LOPES
:owner:         rdlopes
:email:         mailto:rui.d.lopes@me.com
:project:       tfhe-java
:key:           {owner}_{project}
:repo:          https://github.com/{owner}/{project}
:ci:            {repo}/actions/workflows/ci.yaml
:cd:            {repo}/actions/workflows/cd.yaml
:linkedin:      https://www.linkedin.com/in/rdlopes-fr
:badges:        https://img.shields.io/badge
:license:       https://opensource.org/licenses/MIT
:toc:
:toclevels: 3

image:{badges}/License-MIT-yellow.svg[link={license},title=MIT License]
image:{ci}/badge.svg[link={ci},window=_blank]
image:{cd}/badge.svg[link={cd},window=_blank]

https://docs.zama.ai/tfhe-rs[Zama TFHE^] wrapper enabling homomorphic encryption in Java using the Foreign Function & Memory API (Project Panama).

== Overview

TFHE Java is a Java wrapper for the https://github.com/zama-ai/tfhe-rs[Zama TFHE-rs library], providing access to Torus Fully Homomorphic Encryption (TFHE) operations directly from Java applications.
This library enables developers to perform computations on encrypted data without decrypting it first, ensuring privacy and security in cloud computing scenarios.

=== What is TFHE?

TFHE (Torus Fully Homomorphic Encryption) is a cryptographic scheme that allows arbitrary computations to be performed on encrypted data without revealing the underlying plaintext.
Key features include:

* **Fully Homomorphic**: Supports both addition and multiplication operations on encrypted data
* **Bootstrapping**: Automatic noise management to enable unlimited operations
* **Fast Operations**: Optimized for practical performance in real-world applications
* **Boolean and Integer Support**: Works with both boolean circuits and integer arithmetic

=== Key Benefits

* **Privacy-Preserving Computing**: Perform calculations on sensitive data without exposing it
* **Cloud Security**: Enable secure outsourced computation to untrusted servers
* **Zero-Knowledge Processing**: Process data without learning anything about its content
* **Regulatory Compliance**: Meet strict data protection requirements (GDPR, HIPAA, etc.)

== Installation

Add the following dependency to your `pom.xml`:

[source,xml]
----
<dependency>
    <groupId>io.github.rdlopes</groupId>
    <artifactId>tfhe-java</artifactId>
    <version>[VERSION]</version>
</dependency>
----

=== Requirements

* **Java 24** or later (requires Foreign Function & Memory API support)
* **JVM Arguments**: `--enable-native-access=ALL-UNNAMED`
* **Native Libraries**: Automatically included in the JAR (macOS ARM64 currently supported)

== Quick Start

Here's a simple example of performing homomorphic addition:

[source,java]
----
import io.github.rdlopes.tfhe.lib.U128;

import java.lang.foreign.Arena;
import java.lang.foreign.MemorySegment;

import static io.github.rdlopes.tfhe.lib.TfheNative.*;

public static void main(String... args) {
  // Generate configuration and keys
  try (Arena arena = Arena.ofConfined()) {
      // Create configuration
      MemorySegment configBuilder = arena.allocate(C_POINTER);
      config_builder_default(configBuilder);

      MemorySegment config = arena.allocate(C_POINTER);
      config_builder_build(configBuilder.get(C_POINTER, 0), config);

      // Generate client and server keys
      MemorySegment clientKey = arena.allocate(C_POINTER);
      MemorySegment serverKey = arena.allocate(C_POINTER);
      generate_keys(config.get(C_POINTER, 0), clientKey, serverKey);
      set_server_key(serverKey.get(C_POINTER, 0));

      // Prepare values to encrypt
      MemorySegment value1 = U128.allocate(arena);
      U128.w0(value1, 42);
      U128.w1(value1, 0);
      MemorySegment value2 = U128.allocate(arena);
      U128.w0(value2, 57);
      U128.w1(value2, 0);

      // Encrypt the values
      MemorySegment encrypted1 = U128.allocate(arena);
      fhe_uint128_try_encrypt_with_client_key_u128(value1, clientKey.get(C_POINTER, 0), encrypted1);
      MemorySegment encrypted2 = U128.allocate(arena);
      fhe_uint128_try_encrypt_with_client_key_u128(value2, clientKey.get(C_POINTER, 0), encrypted2);

      // Perform homomorphic addition
      MemorySegment result = U128.allocate(arena);
      fhe_uint128_add(encrypted1, encrypted2, result);

      // Decrypt result
      MemorySegment decrypted = U128.allocate(arena);
      fhe_uint128_decrypt(result, clientKey.get(C_POINTER, 0), decrypted);

      System.out.println("Result: " + U128.w0(decrypted)); // Prints: 99
  }
}
----

== Project Structure

=== Core Components

[source]
----
tfhe-java/
├── src/
│   └── test/java/io/github/rdlopes/tfhe/    # Test classes and examples
├── target/
│   ├── classes/native/                      # Native libraries (runtime)
│   └── generated-sources/tfhe-rs/          # Generated Java bindings
├── tfhe-rs/                                 # Rust TFHE implementation (submodule)
├── pom.xml                                  # Maven configuration
└── README.adoc                              # This documentation
----

=== Generated Bindings

The build process automatically generates Java bindings from the TFHE-rs C API:

* **Package**: `io.github.rdlopes.tfhe.lib`
* **Main Class**: `TfheNative` - Contains all native function bindings
* **Data Types**: `U128`, `Boolean` - Wrapper classes for TFHE data types
* **Memory Management**: Uses Java's Foreign Function & Memory API

=== Key Codebase Parts

==== Native Function Bindings (`TfheNative.java`)

Generated class containing all TFHE operations:

* **Key Generation**: `generate_keys()`, `boolean_generate_keys()`
* **Encryption**: `fhe_uint128_encrypt()`, `boolean_client_key_encrypt()`
* **Decryption**: `fhe_uint128_decrypt()`, `boolean_client_key_decrypt()`
* **Operations**: `fhe_uint128_add()`, `fhe_uint128_sub()`, `boolean_server_key_xor()`

==== Test Helpers (`TfheNativeTestHelper.java`)

Utility classes for testing and examples:

* **Scheme Setup**: `usingU128Scheme()`, `usingBooleanScheme()`
* **Memory Management**: Automatic arena cleanup
* **Key Management**: Automated key generation and cleanup

==== Data Type Wrappers

* **U128**: 128-bit unsigned integer operations
* **Boolean**: Boolean circuit operations
* **Memory Segments**: Direct memory access for performance

=== TFHE-rs Submodule

The project includes the complete Zama TFHE-rs library as a Git submodule:

* **Core Library** (`tfhe/`): Main TFHE implementation
* **FFT Operations** (`tfhe-fft/`): Fast Fourier Transform optimizations
* **Number Theory** (`tfhe-ntt/`): Number Theoretic Transform
* **Zero-Knowledge** (`tfhe-zk-pok/`): Zero-knowledge proofs
* **Benchmarks** (`tfhe-benchmark/`): Performance testing

== Building from Source

=== Prerequisites

1. **Java 24** (Temurin distribution recommended)
+
[source,bash]
----
# Using SDKMAN
sdk install java 24-tem
sdk use java 24-tem
----

2. **Rust Toolchain** with nightly support
+
[source,bash]
----
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
rustup toolchain install nightly
----

3. **jextract Tool** (version 22)
+
[source,bash]
----
# Download and setup jextract (macOS ARM64)
curl https://download.java.net/java/early_access/jextract/22/6/openjdk-22-jextract+6-47_macos-aarch64_bin.tar.gz --output jextract.tar.gz
tar -xzf ./jextract.tar.gz -C .
sudo xattr -r -d com.apple.quarantine ./jextract-22/
export PATH=$PATH:$(pwd)/jextract-22/bin
----

4. **macOS** (currently required for native dependencies)

=== Build Process

[source,bash]
----
# Clone with submodules
git clone --recursive https://github.com/rdlopes/tfhe-java.git
cd tfhe-java

# Or initialize submodules if already cloned
git submodule update --init --recursive

# Build the project
./mvnw package
----

=== Build Phases

The build process involves several automated phases:

1. **Submodule Update**: Updates the tfhe-rs Rust submodule
2. **Rust Compilation**: Compiles TFHE library with C API using `cargo +nightly build --release --features=high-level-c-api`
3. **Binding Generation**: Uses jextract to generate Java bindings from C headers
4. **Java Compilation**: Compiles Java code including generated bindings
5. **Native Library Packaging**: Copies native libraries to `target/classes/native/`

== Development Guidelines

=== Memory Management

Always use `Arena.ofConfined()` for automatic memory cleanup:

[source,java]
----
try (Arena arena = Arena.ofConfined()) {
    MemorySegment data = arena.allocate(C_POINTER);
    // Use data...
} // Automatic cleanup
----

=== Error Handling

TFHE native functions return 0 for success, non-zero for errors:

[source,java]
----
int result = fhe_uint128_add(lhs, rhs, output);
assertThat(result).isZero(); // Verify success
----

=== Performance Considerations

* **Key Reuse**: Generate keys once and reuse them
* **Memory Efficiency**: Use appropriate data types (U128 vs Boolean)
* **Batch Operations**: Group operations when possible
* **Native Optimization**: TFHE operations are CPU-intensive

=== Debugging

* **Rust Backtraces**: Set `RUST_BACKTRACE=full` environment variable
* **Native Access**: Ensure `--enable-native-access=ALL-UNNAMED` JVM flag
* **Library Path**: Verify native libraries are accessible
* **Memory Leaks**: Use Arena for automatic memory management

== License

This project is licensed under the MIT License - see the link:{license}[LICENSE] for details.

== Author

image:{badges}/By_Mail-white?style=social&logo=icloud&label=Rui_LOPES[link={email},window=_blank]

image:{badges}/On_LinkedIn-white?style=social&logo=logmein&label=Rui_LOPES[link={linkedin},window=_blank]

== Acknowledgments

* https://www.zama.ai/[Zama] for the excellent TFHE-rs library
* OpenJDK Project Panama for Foreign Function & Memory API
* The homomorphic encryption research community
